---
title: 'spreadr: A R package to simulate spreading activation in a network'
author: "Cynthia S. Q. Siew"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_float: true
vignette: >
  %\VignetteIndexEntry{Introduction}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

<style>
p { text-align: justify }
</style>

# Introduction

The notion of spreading activation is a prevalent metaphor in the cognitive sciences; however, the tools to implement spreading activation in a computational simulation are not as readily available.
This vignette introduces the spreadr R package (pronunced 'SPREAD-er'), which can implement spreading activation within a specified network structure.
The algorithmic method implemented in `spreadr` subroutines followed the approach described in Vitevitch, Ercal, and Adagarla (2011), who viewed activation as a fixed cognitive resource that could “spread” among connected nodes in a network.
See Vitevitch et al. (2011) for more details on the implementation of the spreading activation process.

# Installation {.tabset}

You can choose to install the stable version from CRAN, or the development build from GitHub.

## Stable (CRAN)

```{r eval=FALSE}
install.packages("spreadr")
```

If you encounter any bugs or issues, please try the development build first.
The bug or issue may have already been fixed on GitHub, but not yet propagated onto CRAN.

## Development (GitHub)

```{r eval=FALSE}
install.packages("remotes")
remotes::install_github("csqsiew/spreadr")
```

If you encounter any bugs or issues, please try the development build first.
The bug or issue may have already been fixed on GitHub, but not yet propagated onto CRAN.

# Example with a phonological network

In this example, we will simulate spreading activation in a small sample portion of a phonological network (Ying and Vitevitch 2009) which is automatically loaded with spreadr.
This phonological network is unweighted and undirected, but spreadr supports weighted and directed graphs as well.
This makes it is possible to simulate spreading activation in a weighted network where more activation is passed between nodes that have "stronger" edges, or in a directed (asymmetric) network where activation can pass from node *i* to node *j* but not necessarily from node *j* to node *i*.

You may substitute any network in place of this example one.

## Describing the network {.tabset}

The network for spreading activation must be either an `igraph` object or an adjacency matrix.

### Using an igraph object

`pnet`, an `igraph` object representing our sample phonological network is automatically loaded with the spreadr library.

```{r message=FALSE}
library(spreadr)
library(igraph)

pnet  # inspect the igraph object
```

```{r eval=FALSE}
plot(pnet)
```
<!-- Behind the scenes, we want to generate identical plots, so save a layout.
     This is hidden because I don't want to make the vignette too complex. -->
```{r echo=FALSE}
set.seed(1)
layout <- layout_with_fr(pnet)
plot(pnet, layout=layout)
```

Don't worry if your plot does not look exactly as above.
The layout of the nodes is determined stochastically.

### Using an adjacency matrix

`pnetm`, an adjacency matrix representing our sample phonological network is automatically loaded with the spreadr library.

```{r message=FALSE}
library(spreadr)
library(igraph)
set.seed(1)

pnetm[1:5, 1:5]  # inspect the first few entries
```

```{r eval=FALSE}
plot(graph_from_adjacency_matrix(
  pnetm, mode="undirected")) # visualise the graph
```
```{r echo=FALSE}
plot(graph_from_adjacency_matrix(
    pnetm, mode="undirected"),
  layout=layout)
```

For those following along: don't worry if your plot does not look exactly as above.
The layout of the nodes is determined stochastically.

## Create a dataframe with initial activation values

The user must then specify the initial activation level(s) of node(s) in the network in a dataframe object with two columns labeled node and activation. Below the node labeled “N1” was assigned 20 units of activation. The user can choose to provide different activation values, or initialize more nodes with various activation values.

```{r eval=FALSE}
initial_df <- data.frame(node = 'N1', activation = 20, stringsAsFactors = F)
initial_df
```

## Run the simulation

We are finally ready to run the simulation. In this step, the user must specify the following arguments and parameters in the `spreadr` function:

(i) *start_run*: the dataframe (`initial_df`) specified in the previous step that contains the activation values assigned to nodes at t = 0;
(ii) *decay*, d: the proportion of activation lost at each time step (range from 0 to 1);
(iii) *retention*, r: the proportion of activation retained in the originator node (range from 0 to 1);
(iv) *suppress*, d: nodes with activation values lower than this value will have their activations forced to 0. Typically this will be a very small value (e.g., < 0.001);
(v) *network*: the network (must be an igraph object or a non-zero matrix) on which the spreading of activation occurs on, and
(vi) *time*, t: the number of times to run the spreading activation process for.
(vii) *create_name*: creates numbers/names for nodes if needed, default is TRUE.

```{r eval=FALSE}
result <- spreadr::spreadr(start_run = initial_df, decay = 0,
                              retention = 0.5, suppress = 0,
                              network = g, time = 10)
```

## Results

The output is a dataframe with 3 columns labeled *node*, *activation*, and *time*, and contains the activation value of each node at each time step. The output can be easily saved as a .csv file for further analysis later. A plot showing the activation levels of each node in the network at each time step is shown below.

```{r eval=FALSE}
head(result, 10) # view the results
tail(result, 10)
# write.csv(result, file = 'result.csv') # save the results

library(ggplot2)
a1 <- data.frame(node = 'N1', activation = 20, time = 0) # add back initial activation at t = 0
result_t0 <- rbind(result,a1)
ggplot(data = result_t0, aes(x = time, y = activation, color = node, group = node)) +
  geom_point() + geom_line() + ggtitle('unweighted, undirected network') # visualize the results
```

# Additional examples

This section shows how spreadr can be implemented in a weighted network (i.e., the edges in the network can have different weights) and a directed network (i.e., the edges in the network are not symmetric).

(i) Weighted, undirected network

```{r eval=FALSE}
# weighted, undirected network example
g_w <- g
set.seed(2)
E(g_w)$weight <- runif(gsize(g_w)) # make the edges in the network have different weights ranging from 0 to 1 (excluding extreme values)

result_w <- spreadr::spreadr(start_run = initial_df, decay = 0,
                              retention = 0.5, suppress = 0,
                              network = g_w, time = 10)

result_w_t0 <- rbind(result_w, a1) # add back initial activation at t = 0
ggplot(data = result_w_t0, aes(x = time, y = activation, color = node, group = node)) +
  geom_point() + geom_line() + ggtitle('weighted, undirected network') # visualize the results
```

As you can see from the plot, the result is slightly different from the original example with unweighted edges. More activation is passed to the node that is more "strongly" connected to the originator node.

(ii) Unweighted, directed network

For this example, we will create the network via an adjacency matrix.

```{r eval=FALSE}
# unweighted, directed network example
set.seed(3)
g_d_mat <- matrix(sample(c(0,1), 100, replace = T), 10, 10) # make a matrix and randomly fill some cells with 1s
diag(g_d_mat) <- 0 # remove self-loops
g_d_mat

# spreadr will work on an adjacency matrix too
result_d <- spreadr::spreadr(start_run = data.frame(node = 1, activation = 20, stringsAsFactors = F),
                             decay = 0,
                              retention = 0.5, suppress = 0,
                              network = g_d_mat, time = 10)

result_d_t0 <- rbind(result_d, data.frame(node = 1, activation = 20, time = 0)) # add back initial activation at t = 0
ggplot(data = result_d_t0, aes(x = time, y = activation, color = node, group = node)) +
  geom_point() + geom_line() + ggtitle('unweighted, directed network')
```

The (_i_, _j_) entry of the adjacency matrix should represent the edge going from source node _i_ to target node _j_.
See below and compare it to the plot above.

```{r eval=FALSE}
data.frame(node = 1:10, edge = g_d_mat[,1])
data.frame(node = 1:10, edge = g_d_mat[1,])
```

# References

Siew, C. S. Q. (under review). spreadr: A R package to simulate spreading activation in a network.
Vitevitch, M. S., Ercal, G., & Adagarla, B. (2011). Simulating retrieval from a highly clustered network: Implications for spoken word recognition. *Frontiers in Psychology, 2*, 369.
